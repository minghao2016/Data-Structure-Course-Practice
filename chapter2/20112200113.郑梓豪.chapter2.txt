2.8  假设需要生成前N个自然数的一个随机置换。这个程序常常用于模拟一些算法。我们假设存在一个随机数生成器r，它有方法randInt(i,j)，以相同的概率生成i和j之间的一个整数。下面是三个算法：

(1) 如下填入从 a[0] 到 a[N-1] 的数组a：为了填入a[i]，生成随机数直到它不同于已经生成的a[0], a[1], a[2], … , a[i-1]时再填入a[i]；

(2) 同算法(1)，但是要使用一个附加的数组，称之为used数组。当一个随机数ran最初被放入数组a的时候，设置used[ran] = true。就是说，当用一个随机数填入a[i]的时候，可以用一步来测试是否该随机数已经被使用。而不是算法(1)中可能的i步；

(3) 填写该数组a[i]=i+1。然后

	for ( i = 1; i < n; i++)
		swap ( a[i], a[ randInt (0, i) ] );



一、关于置换的合法性：

证明：对于algo1.2.3，我们用递归的思想，只需要说明a[1]的确定是随机且均匀的即可。下面分别来看这三种算法对于a[1]的影响：

algo1. 
	a[i] = randInt(1, N); // i from 0 to N-1; Besides, the randInt would generate a uniformed distribution series from 1 to N.

algo2.
	a[i] = randInt(1, N); // same as algo1.

algo3.
	a[i] = i + 1; 		   // a[1] was initialize as 1.
	for (int i = 1; i < N; i++) {
        		swap(a[i], a[randInt(0, i)]);  	// a[1] can be swap to anywhere else with same probability.
    	}

需要注意的是，我们已假定方法 randInt(1, N) 可以为我们生成1-N的均匀分布的数。 


二、算法运行时间分析：

algo1. 

	while (i < N) {
        		a[i] = randInt(1, N);
        		for (int k = 0; k < i; k++) {
            		if ( a[i] == a[k]) {
                		i--;
                		break;
            		}
        		}
        		i++;
    	}

/* 一个while语句，长度为N；内嵌一个for循环，循环变量k的最大值为N，且最坏的情况就是N。所以从最坏的意义上来说，算法是O(N^2)的。但若从概率的角度看，内层for循环的每一步，期望能跳出(break)的步数都是i/2。  */


三、实验

Algo 1.	 O(N)	 O(N^2)	 O(Nlog(N))
-------------------------------------------------
N=250	 0.000003	 0.000775	 0.000017
N=500	 0.000005	 0.002695	 0.000033
N=1000	 0.000012	 0.011860	 0.000082
N=2000	 0.000024	 0.047324	 0.000180
N=4000	 0.000057	 0.227092	 0.000471
N=8000	 0.000119	 0.951365	 0.001069
N=16000	 0.000000	 0.000000	 0.000000
-------------------------------------------------

Algo 2.		 O(N)	 O(N^2)	 O(Nlog(N))
---------------------------------------------------------
N=25000	 0.000000	 0.000609	 0.000000
N=50000	 0.000000	 0.001522	 0.000000
N=100000	 0.000000	 0.003264	 0.000000
N=200000	 0.000000	 0.004336	 0.000000
N=400000	 0.000000	 0.009251	 0.000000
N=800000	 0.000000	 0.019048	 0.000000
N=1600000	 0.000000	 0.043246	 0.000000
---------------------------------------------------------

Algo 3.		 O(N)	 O(N^2)	 O(Nlog(N))
---------------------------------------------------------
N=100000	 0.000000	 0.002614	 0.000000
N=200000	 0.000000	 0.005638	 0.000000
N=400000	 0.000000	 0.010878	 0.000000
N=800000	 0.000000	 0.025930	 0.000000
N=1600000	 0.000000	 0.060538	 0.000001
N=3200000	 0.000000	 0.000000	 0.000000
N=6400000	 0.000000	 0.000000	 0.000000
---------------------------------------------------------
MacBook-Air:gcc white$ 



